# About flow

Ayrton Senna's experience during a qualifying lap at Monaco's 1988 Grand Prix illustrates the importance of flow perfectly.

> I was already on pole, and I just kept going. Suddenly I was nearly two seconds faster than anybody else, including my team mate with the same car. And suddenly I realised that I was no longer driving the car consciously. I was driving it by a kind of instinct, only it was a different dimension. It was like I was in a tunnel.

[That lap has been described as the greatest lap of Senna's career](http://youtube.com/watch?v=K9QH8-lKEYY).

Flow is a state of complete immersion in an activity, a state where the outside and inside world merge into one and the person is simply _present_. Mihaly Csikszentmihalyi - the father of flow research in psychology - describes flow as "completely focused motivation. A single-minded immersion that represents perhaps the ultimate in harnessing the emotions in service of performing and learning."

In his essay [Holding a program in one's head](http://paulgraham.com/head.html), Paul Graham explains that to be effective, programmers must be able to hold an entire program in their head while they work. It's the only way the problem and its solution can have the plasticity needed to make sweeping changes and improvements.

Because programmers tend to work at the limits of their tolerance for complexity, holding a program in one's head is only possible in a state of flow.

But flow is a fragile balance between many opposing forces. The programmer must be willing and able to completely focus on the task at hand, they must have a clear goal to work towards, fresh challenges must be coming in at the right pace, and they must feel a sense of purpose, even joy, in what they're doing.

## The autotelic personality

In his work, Csikszentmihalyi describes a type of personality that can experience episodes of flow more easily and more often than most people.

Researching flow in a lab is too difficult to get proper results, but evidence keeps wagging its eyebrows suggestively, hinting at the validity of something called an "autotelic personality".

If there is such a thing, I think programmers generally apply:

 * Curious

It [has been drawn in stick figures](http://xkcd.com/242/) that when a normal person pulls a lever saying "Don't press this" and gets electrocuted, they think to themselves "Heh, I shouldn't have done that." But when an engineer pulls that same lever, they go "Huh, I wonder if that happens every time"

All programmers are engineers at heart, no matter what their formal qualifications might say. 

 * Persistent

Relentlessly hunting down bugs is a source of great pride for most programmers, and many would sooner go without sleep than allow a bug to remain in production code. More experienced developers will often go to sleep once they realize they've started making silly mistakes, but they will never forget a bug that's taunting them.

 * Not self-centered

It could be argued that programmers are very selfless people - the existence of communities like StackOverflow, large numbers of conferences where speakers share their knowledge for free, numerous blogs and free tutorials, not to mention the large open source community that's given us something as powerful as the Linux operating system and the stack most of the internet runs on. All of those are done holistically ... well, mostly. Everybody gains from having a good standing in the community.

 * Often performs activities for intrinsic reasons

Even a casual perusal of Github repositories will show that a lot of programmers indulge in so-called "pet projects" - little programs developed for the fun of it, to sharpen the saw if you will. Interestingly enough, flow is much easier to experience on pet projects than large for-money behemoths.

As a group of people, programmers exhibit all the traits of an autotelic personality. This would suggest flow is much more prevalent among programmers than in other groups of people, which might also start to explain why we programmers are often perceived as night walkers.

## Is achieving flow easier at night?

Yes. At least for those of us who manage to think clearly and who still feel relatively rested. For many, the structure of their life makes this impossible.  So some approach the night from its other end, while others learn to work during the day.

### Avoiding Decision Fatigue

The biggest enemy to evening and night-time productivity is decision fatigue.

Most people experiencing decision fatigue don't recognize it for what it is, but if you've ever felt well-rested physically and still couldn't think clearly, like your brain was tired, you've experienced decision fatigue.

[Research](http://www.nytimes.com/2011/08/21/magazine/do-you-suffer-from-decision-fatigue.html) has shown that humans can only accept a limited amount of decisions every day. After that, we usually go with the default action, or are so incapable of making a decision we can't perform the action at all.

Not only that, it's been shown that even the tiniest decision factors into the quota - everything from deciding what to eat for breakfast, to which outfit to wear and what websites to read now or later. This is why the checkout aisle in your supermarket is filled with tiny things you otherwise wouldn't have bought and why people instinctively want to "sleep on it" when making big decisions.

Depending on how a programmer's day is structured, working in the evening can be a godsend or a spaghetti code mess-producing mistake. The important thing is to be well-rested regardless of the time when you start working.

An interesting side-effect of decision fatigue in its early stages is that you can often focus better _because_ you are a bit tired. You know there's no other choice but to power through the work, so you sit down, ignore everything else and just code.

But eventually decision fatigue catches up, and you find yourself thinking too long about simple things like what to name your files.

### A Distraction-Free Mind

Flow is marked by an intense, almost meditative, calm. No other thoughts can invade your brain than what pertains to the task at hand. Everything else ceases to exist.

But when things are hanging over your head, so to speak, achieving flow is nearly impossible for most people. The mental clarity and emotional calm just isn't there.

Maybe it's an errand you still have to run, or an important email you mustn't forget to send. Perhaps there's just some stressful stuff going on and you aren't Irish enough not to worry about it. Sometimes you simply have an IRC chatroom open in a hidden window. 

If there's something tugging at your brain, you might as well forget about flow.

Perhaps the biggest thing everyone's got tugging on their brain is the anticipation of imminent distraction. You _know_ something is going to happen in an hour or two. Sometimes it's a big meeting, other times you have to be around to take a call - either way, it can be very distracting even if you do know when the distraction is going to happen.

Everyone knows those moments where it's 2:35 and you expect something to happen at 3:00. You try to get work done, but you keep looking at the clock every two minutes. Then you might as well check a tweet or two.  When 3:00 rolls around, you haven't done anything useful for half an hour.

Not knowing when, or even if, a distraction is going to happen only makes it worse. You're paying half attention to your code and half attention to your environment at all times. When a colleague sitting across the room says something, you immediately listen in, process what you've heard, decide it wasn't about you, and get back to work.

You'd love to tune out completely, but sometimes it _is_ for you and you have to respond. Random rewards are after all the strongest behavior creator in existence.

Something wonderful happens at night, though. There are no more distractions (at least,  no more threat of imminent distraction). Since everyone is asleep, you can be fairly certain nobody is going to give you a call, nobody will ask you a random question, and nothing interesting is going to happen on the internet.

For at least ten hours _nothing_ will be expected of you. Nothing. That's a lot of freedom right there.

### Forming Habits

Have you ever had a habitual activity fall through? Say you go to the gym every Wednesday at six in the evening. Or you always watch a certain show on television at exactly 7PM every Thursday.

When something comes up and you can't do what you're used to, it doesn't feel like you've gained an extra hour or two. No, you feel lost, like you suddenly don't know what to do with all this extra time you've been given. So you end up wasting it, clicking one more link on Reddit, or flicking through one more channel on TV.

As they say, habit is an iron shirt. 

Getting used to something takes a concerted effort of a few weeks. But once the habit is built, it's almost impossible to change. Just remember how odd it feels when you forget to brush your teeth in the morning!

It's the same thing with flow - it's simply easier at certain times in the day. This depends on a lot of things, like how many other obligations you have, what the schedule of the people around you might be and even your internal cycles of activity, which tend to depend a lot on meal times.

But once you get used to working at a certain point in the day, suddenly your other habits start forming around these patterns instead of the other way around. It's a self-reinforcing pattern.

When do these habits form? Since most programmers start very young, let's take a young high-school aged programmer as an example.

This programmer needs to get up every morning at a predetermined time so they can get to class. They are stuck in class until 3PM. They come home, their parents want them to do a bunch of chores, there's homework to tend to, and before they know it, it's already 9PM or 10PM.

And now, finally, there's nothing hanging over their heads anymore. They can get to programming.

In a few years, this person will be in college.  There are much fewer external time constraints, but after many years of _starting_ coding in the evening, they associate the activity with night-time. They simply can't get their mind to thin about coding before 9PM anymore.

Thus, another night-time hacker is born. With years and piling pressure from the outside (work, family, etc.), their schedule will naturally shift around the other demands in their lives.

But when a project _needs to get done_, they go back to their safe place and code all night.

## Two types of flow and what keeps them going

Once a programmer gets into flow, it is paramount that they stay there for as long as possible. Not only will they get more work done simply because they're spending more time working, flow is a self-fulfilling prophecy. The more time you spend in flow, the easier getting into flow becomes and the deeper the flow becomes.

But not all flow is created equal. Sometimes it will leave you energized and awash with even better ideas, other times flow might leave you completely exhausted in the end having just squeezed every last ounce of awesome out of you.

The difference depends mostly on what kept the flow going.

### Panic mode

Every one of us probably knows that feeling of sheer panic that only a hard deadline can bring. The moment you realize The Paper is due next morning, it's already 10PM, you've just come home from an evening of beers and suddenly discovered you _still_ haven't picked up that book from the library. You know, the one with all the info you need to write this thing.

That's when real productivity begins for most people. That's when they can really tell what they're made of.

The outside world melts away as you pound the keyboard in a furious panic. The Internet stops existing. Skype's alerts are as significant as a supernova going off in a distant galaxy. Nothing exists but you and your work.

Come morning, you are tired, cranky, effectively two days behind on sleep, but victorious. It might not turn out to be a perfect mark, but it's better than a fail. You know you could have done better if only you had started earlier, but you didn't.

What just happened was a panic-induced flow. 

You spent the entire night essentially in a fight or flight response. Adrenaline coursing through your veins made you hyped up, focused. But it was also exhausting. Your only reward was a deadline not missed. The price, half-assed work and the subsequent day completely wasted because you will be too tired to think.

### Deep fulfilment

The converse of panic flow is the good kind. A drug-like trance that leaves you energized, ready to take on the world. And if not for annoying physical limitations, you would happily spend all your days in such a state.

For me, the typical situation is something like this.

I have spent the past few days rolling an interesting problem around my mind. Either it's an algorithm I want to try implementing, or a problem I feel could be solved for many people. Or sometimes it's as simple as feeling a blog post must be written to address a topic.

I let the feeling fester for a while. On purpose. Indulging immediately would ruin the flow because the mind must first have time to process the idea in as much detail as possible.

One evening, I will sit down and begin.

The outside world melts away. Time becomes a blur and before I know it, morning comes. What the hell? Wasn't it just 8PM half an hour ago?

In reality, I have just spent twelve hours in complete rapture. Engrossed in the bigger picture, I solved sub-problem after sub-problem, each just challenging enough to keep me going.

At this point, my body has had enough and _I do need to get some sleep_.

But the very next day I will jump out of bed - yes literally - and even brushing my teeth might feel like too much waiting to get back into the code.

That's the good kind of flow. The one you want. Because this is sustainable.  Were it not for practical limitations one could live for months on end like this.

Panic flow … that kind is only good for one or two consecutive days. Then it takes weeks before the brain is ready again.


## Why is day-time particularly bad for flow?

Now we can all agree why night is particularly good for flow, but it is important to remember this is not the only time when programmers can reach flow. Mornings, especially very early mornings, are a popular choice as well. Even though this is just approaching the night from a different end, the cultural baggage attached is different.

People who start work early in the morning, especially before dawn, are often seen as hard-working and commendable, while those who choose to work late into the night, often right until dawn, are often seen as lazy slobs who sleep the whole day away.

Whether a programmer chooses late nights or early mornings, doesn't really change the goal - to avoid working on high intensity flow activities during the day.

The answer I got when asking programmers why they don't like working during the day sounds very asocial indeed: because other people are awake.

### Cost of interruption

There is a ritual to getting in the flow. 

Usually the first thing people will do when sitting down to code is check Facebook, Twitter and email. Not always in that order, not always all of them.  Sometimes other social networks completely; Reddit, Hacker News and Stack Overflow are popular options.

Warm caffeinated beverages go very well with this sort of activity. Making them doesn't take much time, but they introduce an impetus to keep procrastinating until you've finished the cup.

We call this procrastination, but the term carries connotations that aren't fully warranted. Don't think of it as putting off work. It's more like defragging one's brain. Making sure there are no more lingering thoughts in there, no notifications left unclicked, no important questions left unanswered.

After anywhere from a few minutes to an hour, work can finally begin.

First, a programmer needs to make sure they are working off the latest version of the project. Then they must check whatever issue tracking system they're using. Having a clear goal is paramount to achieving flow and getting anything done.

Next up, the work environment.

Swing by a programmer's computer some time and you will likely see a desktop littered with open windows, consoles, IDE's, text editors, documentation. Everything.

Unlike many (most?) people who use even modern computers as a single application environment and often maximize whatever software they are using to fill the whole screen, programmers are different beasts altogether.

There's usually a text editor and a console or two, perhaps a debugger, a browser with some documentation is almost mandatory as well. Often all these tools will be unified in a single Integrated Development Environment (IDE), which is a sophisticated way of saying "A bunch of stuff, but in a single window".

Loading up a work environment like that takes time. Not because our computers are slow, but because knowing which tools you need requires understanding what you're about to work on. The right environment is so important that a session crash or a context switch to a different set of tools can be totally devastating to a programmer's productivity.

Then, the programmer must prime their mind.

Programs are a conversation between programmer and computer. Computer and user. The programmer's job is breaking down a problem into understandable bits and explaining the solution to the computer in such a way it can be executed perfectly every time. (Or at least well enough.)

Loading a program into your brain means learning its language. Functions are verbs, variables are nouns and there's plenty of things in between. Notes can help. Keeping tools open also helps. But nothing will get you over just how much brain power it takes to understand the entire software project.

Every time you lose sight of the whole system, you have to build it again, like constructing a house of cards. Once you understand the language, you have to arrange it in your mind so the space can be freely traversed, you can close your eyes and _see_ how different parts of the system affect each other.

Only after this stage has been reached is a programmer fully effective. Only then can they have any chance of reaching flow because they don't have to stop every five minutes to figure out how their code fits in the larger picture and whether it's even doing what it's supposed to.

When you interrupt a programmer, their house of cards can come crashing down. They have to start the whole process all over again, and it's going to take a while before they're back to full steam.

### Distractions

Not all distractions are created equal and not all will cause an interruption.

You will often see a programmer walking along the street, eyebrow furrowed, peering into the tips of their shoes, lips clenched. Do _not_ try talking to them. This is a programmer who is deep in thought on a problem, struggling hard to prevent the house of cards from tumbling.

Ask them a question, and it can all be gone in the blink of the eye. All that hard work and deep concentration, just gone. Simply because they have to think about something else.

It almost doesn't matter how simple a question you're asking. Anything requiring a proper answer will cause a lot of trouble. Most programmers tend to resort to communicating with grunts and various sounds. Or simply saying "Yeah yeah sure" to everything.

The danger is not knowing they weren't really listening to you and just said something so you'd go away and stop bothering them. Flailing hands and raised voices can also happen.

Almost more important than whether the programmer had to do some thinking in response to a distraction is whether they chose to be distracted or it was something outside their control.

Most people working with computers will often distract themselves. After being focused for a while they will start wasting time on the internet. Nobody told them to do this. Often there isn't even a notification saying something new happened, it just feels like "Hey, I haven't done that in a while! I should check if there's anything new!" There isn't.

(I'm lying, there's always _something_ new. But it usually isn't interesting or something that feels worth the distraction.)

However, random rewards keep us hooked and we can't help ourselves but to check. Like a lab rat desperately trying to get the next nugget of food, we press the magical big button. 

If a programmer can prevent themselves from straying off into the wild internet and getting lost for an hour, this sort of distraction won't cause much of a problem. In just a few minutes, they will be back to coding at full blast. These sort of distractions are usually just our brain saying we should take a break.

Conversely, even the shortest external distraction can be devastating.

Most distractions come from coworkers who are just trying to get their work done, but need your involvement - the gordian knot of working in a team of programmers is having two programmers who depend on one another. Both are in a state of flow. One of them has a problem. Do they destroy their productivity by waiting on the other person to naturally come out of flow, or destroy the other person's productivity by interrupting them?

Hopefully they can work on something else, but this requires a context switch to a different problem as well.

Programmers also run on a different schedule than most people, which can cause lots of problems. When the cost of getting started is as high as it is for programmers, it doesn't make sense to work in stretches shorter than a few hours. The prototypical calendar app divides the day into hours and half hours, and that's how most of the world thinks of time, as well.

Respect their schedule and  **do not distract them**. Put your request in the queue and wait for _them_ to come to _you_.  Otherwise, you risk making them start at the very beginning again.
